package tcommon

import (
	"reflect"
	"sort"
	"testing"
)

type Implementation struct {
	Name string
	F    func([]uint, func([]uint))
}

var (
	cases = []struct {
		s        []uint
		expected [][]uint
	}{
		{
			[]uint{},
			[][]uint{
				{},
			},
		},
		{
			[]uint{1},
			[][]uint{
				{1},
			},
		},
		{
			[]uint{1, 2},
			[][]uint{
				{1, 2},
				{2, 1},
			},
		},
		{
			[]uint{1, 2, 3},
			[][]uint{
				{1, 2, 3},
				{1, 3, 2},
				{2, 1, 3},
				{2, 3, 1},
				{3, 1, 2},
				{3, 2, 1},
			},
		},
		{
			[]uint{1, 2, 3, 4},
			[][]uint{
				{1, 2, 3, 4},
				{1, 2, 4, 3},
				{1, 3, 2, 4},
				{1, 3, 4, 2},
				{1, 4, 2, 3},
				{1, 4, 3, 2},
				{2, 1, 3, 4},
				{2, 1, 4, 3},
				{2, 3, 1, 4},
				{2, 3, 4, 1},
				{2, 4, 1, 3},
				{2, 4, 3, 1},
				{3, 1, 2, 4},
				{3, 1, 4, 2},
				{3, 2, 1, 4},
				{3, 2, 4, 1},
				{3, 4, 1, 2},
				{3, 4, 2, 1},
				{4, 1, 2, 3},
				{4, 1, 3, 2},
				{4, 2, 1, 3},
				{4, 2, 3, 1},
				{4, 3, 1, 2},
				{4, 3, 2, 1},
			},
		},
		{
			[]uint{1, 2, 3, 4, 5},
			[][]uint{
				{1, 2, 3, 4, 5},
				{1, 2, 3, 5, 4},
				{1, 2, 4, 3, 5},
				{1, 2, 4, 5, 3},
				{1, 2, 5, 3, 4},
				{1, 2, 5, 4, 3},
				{1, 3, 2, 4, 5},
				{1, 3, 2, 5, 4},
				{1, 3, 4, 2, 5},
				{1, 3, 4, 5, 2},
				{1, 3, 5, 2, 4},
				{1, 3, 5, 4, 2},
				{1, 4, 2, 3, 5},
				{1, 4, 2, 5, 3},
				{1, 4, 3, 2, 5},
				{1, 4, 3, 5, 2},
				{1, 4, 5, 2, 3},
				{1, 4, 5, 3, 2},
				{1, 5, 2, 3, 4},
				{1, 5, 2, 4, 3},
				{1, 5, 3, 2, 4},
				{1, 5, 3, 4, 2},
				{1, 5, 4, 2, 3},
				{1, 5, 4, 3, 2},
				{2, 1, 3, 4, 5},
				{2, 1, 3, 5, 4},
				{2, 1, 4, 3, 5},
				{2, 1, 4, 5, 3},
				{2, 1, 5, 3, 4},
				{2, 1, 5, 4, 3},
				{2, 3, 1, 4, 5},
				{2, 3, 1, 5, 4},
				{2, 3, 4, 1, 5},
				{2, 3, 4, 5, 1},
				{2, 3, 5, 1, 4},
				{2, 3, 5, 4, 1},
				{2, 4, 1, 3, 5},
				{2, 4, 1, 5, 3},
				{2, 4, 3, 1, 5},
				{2, 4, 3, 5, 1},
				{2, 4, 5, 1, 3},
				{2, 4, 5, 3, 1},
				{2, 5, 1, 3, 4},
				{2, 5, 1, 4, 3},
				{2, 5, 3, 1, 4},
				{2, 5, 3, 4, 1},
				{2, 5, 4, 1, 3},
				{2, 5, 4, 3, 1},
				{3, 1, 2, 4, 5},
				{3, 1, 2, 5, 4},
				{3, 1, 4, 2, 5},
				{3, 1, 4, 5, 2},
				{3, 1, 5, 2, 4},
				{3, 1, 5, 4, 2},
				{3, 2, 1, 4, 5},
				{3, 2, 1, 5, 4},
				{3, 2, 4, 1, 5},
				{3, 2, 4, 5, 1},
				{3, 2, 5, 1, 4},
				{3, 2, 5, 4, 1},
				{3, 4, 1, 2, 5},
				{3, 4, 1, 5, 2},
				{3, 4, 2, 1, 5},
				{3, 4, 2, 5, 1},
				{3, 4, 5, 1, 2},
				{3, 4, 5, 2, 1},
				{3, 5, 1, 2, 4},
				{3, 5, 1, 4, 2},
				{3, 5, 2, 1, 4},
				{3, 5, 2, 4, 1},
				{3, 5, 4, 1, 2},
				{3, 5, 4, 2, 1},
				{4, 1, 2, 3, 5},
				{4, 1, 2, 5, 3},
				{4, 1, 3, 2, 5},
				{4, 1, 3, 5, 2},
				{4, 1, 5, 2, 3},
				{4, 1, 5, 3, 2},
				{4, 2, 1, 3, 5},
				{4, 2, 1, 5, 3},
				{4, 2, 3, 1, 5},
				{4, 2, 3, 5, 1},
				{4, 2, 5, 1, 3},
				{4, 2, 5, 3, 1},
				{4, 3, 1, 2, 5},
				{4, 3, 1, 5, 2},
				{4, 3, 2, 1, 5},
				{4, 3, 2, 5, 1},
				{4, 3, 5, 1, 2},
				{4, 3, 5, 2, 1},
				{4, 5, 1, 2, 3},
				{4, 5, 1, 3, 2},
				{4, 5, 2, 1, 3},
				{4, 5, 2, 3, 1},
				{4, 5, 3, 1, 2},
				{4, 5, 3, 2, 1},
				{5, 1, 2, 3, 4},
				{5, 1, 2, 4, 3},
				{5, 1, 3, 2, 4},
				{5, 1, 3, 4, 2},
				{5, 1, 4, 2, 3},
				{5, 1, 4, 3, 2},
				{5, 2, 1, 3, 4},
				{5, 2, 1, 4, 3},
				{5, 2, 3, 1, 4},
				{5, 2, 3, 4, 1},
				{5, 2, 4, 1, 3},
				{5, 2, 4, 3, 1},
				{5, 3, 1, 2, 4},
				{5, 3, 1, 4, 2},
				{5, 3, 2, 1, 4},
				{5, 3, 2, 4, 1},
				{5, 3, 4, 1, 2},
				{5, 3, 4, 2, 1},
				{5, 4, 1, 2, 3},
				{5, 4, 1, 3, 2},
				{5, 4, 2, 1, 3},
				{5, 4, 2, 3, 1},
				{5, 4, 3, 1, 2},
				{5, 4, 3, 2, 1},
			},
		},
	}
)

func TestPermutation(t *testing.T, impl Implementation) {
	for _, c := range cases {
		sCopy := make([]uint, len(c.s))
		copy(sCopy, c.s)
		got := [][]uint{}
		f := func(x []uint) {
			xCopy := make([]uint, len(x))
			copy(xCopy, x)
			got = append(got, xCopy)
		}
		impl.F(c.s, f)
		if !reflect.DeepEqual(c.s, sCopy) {
			t.Errorf("%s changed the input: %v, expected %v", impl.Name, c.s, sCopy)
		}
		sort.Slice(got, func(i, j int) bool {
			if len(got) == 0 {
				return false
			}
			for index, count := 0, len(got[0]); index < count; index++ {
				if got[i][index] < got[j][index] {
					return true
				}
				if got[i][index] > got[j][index] {
					return false
				}
			}
			return false
		})
		if !reflect.DeepEqual(got, c.expected) {
			t.Errorf("%s(%v, <func>) = %v, expected %v", impl.Name, c.s, got, c.expected)
		}
	}
}
